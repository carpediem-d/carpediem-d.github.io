<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon32.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.ico">
  <link rel="mask-icon" href="/favicon32.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"carpediem-d.github.io","root":"/","scheme":"Mist","version":"8.0.1","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="函数基础 一个典型的函数(function)定义包括：返回部分(return type)、函数名字、由0个或多个形参(parameter)组成的列表以及函数体(function body)。 通过调用运算符(call operator)来执行函数。调用运算符的形式是一对圆括号，他作用于一个表达式，该表达式是函数或指向函数的指针；圆括号内是一个用逗号隔开的实参(argument)列表，用实参初始化函">
<meta property="og:type" content="article">
<meta property="og:title" content="《c++primer》第六章 函数">
<meta property="og:url" content="https:&#x2F;&#x2F;carpediem-d.github.io&#x2F;2020&#x2F;10&#x2F;22&#x2F;%E3%80%8Ac++primer%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0&#x2F;index.html">
<meta property="og:site_name" content="DZY&#39;s site">
<meta property="og:description" content="函数基础 一个典型的函数(function)定义包括：返回部分(return type)、函数名字、由0个或多个形参(parameter)组成的列表以及函数体(function body)。 通过调用运算符(call operator)来执行函数。调用运算符的形式是一对圆括号，他作用于一个表达式，该表达式是函数或指向函数的指针；圆括号内是一个用逗号隔开的实参(argument)列表，用实参初始化函">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-10-22T01:34:13.856Z">
<meta property="article:modified_time" content="2020-10-25T06:40:36.014Z">
<meta property="article:author" content="DZY">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://carpediem-d.github.io/2020/10/22/%E3%80%8Ac++primer%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《c++primer》第六章 函数 | DZY's site</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">DZY's site</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#函数基础"><span class="nav-number">1.</span> <span class="nav-text">函数基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#局部对象"><span class="nav-number">1.1.</span> <span class="nav-text">局部对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数声明"><span class="nav-number">1.2.</span> <span class="nav-text">函数声明</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参数传递"><span class="nav-number">2.</span> <span class="nav-text">参数传递</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#传值参数"><span class="nav-number">2.1.</span> <span class="nav-text">传值参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传引用参数"><span class="nav-number">2.2.</span> <span class="nav-text">传引用参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const形参和实参"><span class="nav-number">2.3.</span> <span class="nav-text">const形参和实参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组形参"><span class="nav-number">2.4.</span> <span class="nav-text">数组形参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#main：处理命令行选项"><span class="nav-number">2.5.</span> <span class="nav-text">main：处理命令行选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#含有可变形参和函数"><span class="nav-number">2.6.</span> <span class="nav-text">含有可变形参和函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#返回类型和return语句"><span class="nav-number">3.</span> <span class="nav-text">返回类型和return语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#无返回值函数"><span class="nav-number">3.1.</span> <span class="nav-text">无返回值函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有返回值函数"><span class="nav-number">3.2.</span> <span class="nav-text">有返回值函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#不要返回局部变量的引用和指针：函数终止意味着局部变量的引用将指向不再有效的内存区域。"><span class="nav-number">3.2.0.0.1.</span> <span class="nav-text">不要返回局部变量的引用和指针：函数终止意味着局部变量的引用将指向不再有效的内存区域。</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#返回数组指针"><span class="nav-number">3.3.</span> <span class="nav-text">返回数组指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数重载"><span class="nav-number">4.</span> <span class="nav-text">函数重载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重载与作用域"><span class="nav-number">4.1.</span> <span class="nav-text">重载与作用域</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#特殊用途语言特性"><span class="nav-number">5.</span> <span class="nav-text">特殊用途语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#默认实参"><span class="nav-number">5.1.</span> <span class="nav-text">默认实参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联函数和constexpr函数"><span class="nav-number">5.2.</span> <span class="nav-text">内联函数和constexpr函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调试帮助"><span class="nav-number">5.3.</span> <span class="nav-text">调试帮助</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数匹配"><span class="nav-number">6.</span> <span class="nav-text">函数匹配</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数指针"><span class="nav-number">7.</span> <span class="nav-text">函数指针</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="DZY"
      src="/images/avatar02.jpg">
  <p class="site-author-name" itemprop="name">DZY</p>
  <div class="site-description" itemprop="description">Live simple,train hard and live a honest life.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/carpediem-d" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;carpediem-d" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://carpediem-d.github.io/2020/10/22/%E3%80%8Ac++primer%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar02.jpg">
      <meta itemprop="name" content="DZY">
      <meta itemprop="description" content="Live simple,train hard and live a honest life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DZY's site">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《c++primer》第六章 函数
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-22 09:34:13" itemprop="dateCreated datePublished" datetime="2020-10-22T09:34:13+08:00">2020-10-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-25 14:40:36" itemprop="dateModified" datetime="2020-10-25T14:40:36+08:00">2020-10-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%8Ac-primer%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《c++primer》</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><ul>
<li>一个典型的函数(function)定义包括：<strong>返回部分</strong>(return type)、<strong>函数名字</strong>、<strong>由0个或多个形参(parameter)组成的列表</strong>以及<strong>函数体</strong>(function body)。</li>
<li>通过<strong>调用运算符</strong>(call operator)来执行函数。调用运算符的形式是一对圆括号，他作用于一个表达式，<u>该表达式是函数或指向函数的指针</u>；圆括号内是一个用逗号隔开的<strong>实参(argument)列表</strong>，用实参初始化函数的形参。</li>
<li>函数的返回类型不能是数组或函数，但可以是指向数组或函数的指针。</li>
</ul>
<a id="more"></a>

<h2 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h2><ul>
<li>在C++语言中，名字有作用域，对象有<strong>生命周期</strong>(lifetime)。<ul>
<li>名字的作用域 时程序文本的一部分，名字在其中可见。</li>
<li>对象的生命周期是程序执行过程中该对象存在的一段时间。</li>
</ul>
</li>
<li>形参和函数体内部定义的变量统称为<strong>局部变量</strong>(local variable)，仅在函数的作用域内可见，同时局部变量还会<strong>隐藏</strong>(hide)在外层作用域中同名的其他所有声明中。</li>
<li>在函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束时才会销毁。局部变量的生命周期依赖于定义的方式。</li>
<li>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为<strong>自动对象</strong>(automatic object)。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。</li>
<li>形参是一种自动对象。</li>
<li>内置类型的未初始化局部变量将产生未定义的值。</li>
<li><strong>局部静态变量</strong>(local static object)在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序中止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</li>
<li><u>如果局部静态变量没有显示的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。</u></li>
</ul>
<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><ul>
<li>函数声明也称作<strong>函数原型</strong>(function prototype)，和函数的定义非常类似，唯一的区别是函数声明无需函数体，用一个分号代替。</li>
<li>函数只能定义一次，但可以多次声明。</li>
</ul>
<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><ul>
<li>形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将绑定到对应的实参上；否则将实参的值拷贝后赋给形参。</li>
<li>当形参是引用类型时，我们说它对应的实参被<strong>引用传递(</strong>passed by reference)或者函数被<strong>传引用调用</strong>。引用形参是它对应实参的别名。</li>
<li>当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被<strong>值传递</strong>(passed by value)或者函数被<strong>传值调用</strong>(called by value)。</li>
</ul>
<h2 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h2><ul>
<li>函数对形参做的所有操作都不会影响实参。</li>
<li>当形参是指针时，可以改变指针所指对象的值，但无法改变实参的值。</li>
</ul>
<h2 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h2><ul>
<li>通过使用引用形参，允许函数改变一个或多个实参的值。</li>
<li>拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型不支持拷贝操作，这时函数应使用引用形参访问该类型的对象。</li>
<li>给函数传入额外的引用实参，可以使函数返回额外信息。</li>
</ul>
<h2 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h2><ul>
<li><u>和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。当形参有顶层const时，传给它常量对象和非常量对象都可以。</u></li>
<li><strong>可以使用非常量初始化一个底层const对象，但反过来不行。同时一个普通的引用必须用同类型的对象初始化。</strong></li>
<li>尽量使用常量引用。</li>
</ul>
<h2 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h2><ul>
<li><p>数组的两个特殊性质（不允许拷贝数组以及使用数组时会将其转换成指针）对我们定义和使用作用在数组上的函数有影响。</p>
</li>
<li><p>尽管不能以值传递的方式传递数组，我们仍可以把形参写成类似数组的形式。数组的大小对函数的调用没有影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尽管形式不同，这三个print函数都是等价的</span></span><br><span class="line"><span class="comment">//每个函数都有一个const int*类型的形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为数组是以指针形式传递给函数的，所以一开始函数并不知道数组的确切大小，调用者应该为此提供一些额外的信息。管理指针形参有三种常用的技术：</p>
<ul>
<li><p><u>使用标记指定数组长度：要求数组本身包含一个结束标记。</u>使用这种方法的典型就是C风格字符串，它储存在字符数组中，并且在最后一个字符后面跟着一个空字符，函数在处理时遇到空字符停止。此方法适用于有明显结束标记且该标记不会与普通数据混淆的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cp)                <span class="comment">//若cp不是一个空指针</span></span><br><span class="line">    <span class="keyword">while</span>(*cp)          <span class="comment">//只要指针所指的字符不是空字符</span></span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; *p++;     <span class="comment">//输出当前字符并将指针向前移动一个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><u>使用标准库规范：传递指向数组首元素和尾后元素的指针。</u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *beg, <span class="keyword">const</span> <span class="keyword">int</span> *<span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(beg != <span class="built_in">end</span>)</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; *beg++ &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">begin</span>(arr), <span class="built_in">end</span>(arr));</span><br></pre></td></tr></table></figure>
</li>
<li><p><u>显示传递一个表示数组大小的形参：专门定义一个表示数组大小的形参</u>，在C程序和过去的C++程序中常常使用这种方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[],<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="built_in">size</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ia[i] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(j, <span class="built_in">end</span>(j) - <span class="built_in">begin</span>(j));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数组引用形参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span><span class="comment">//arr两端的括号没有的话，表示的是含有10个引用的数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> elem : arr)</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只能将函数作用于含有10个整数的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传递多维数组：<code>void print(int (*matrix)[10], int rowsize);</code>或<code>void print(int matrix[] [10], int rowsize);</code></p>
</li>
</ul>
<h2 id="main：处理命令行选项"><a href="#main：处理命令行选项" class="headerlink" title="main：处理命令行选项"></a>main：处理命令行选项</h2><ul>
<li><p>可以给main传递实参，在命令行运行时传递给main函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main函数的两种定义形式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;...&#125;<span class="comment">//argc表示数组中字符串的数量，argv时指向C风格字符串的指针的数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **grav)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">main</span><span class="params">(<span class="keyword">int</span>   argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"argc=   "</span> &lt;&lt; argc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"argv["</span> &lt;&lt; i &lt;&lt; <span class="string">"]="</span> &lt;&lt; argv[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>   <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*假定该main函数位于文件D:\test\test1\Debug\test1.exe，在命令行输入D:\test\test1\Debug\test1.exe this is my code；输出结果为：</span></span><br><span class="line"><span class="comment">argc=   5</span></span><br><span class="line"><span class="comment">argv[0]=D:\test\test1\Debug\test1.exe</span></span><br><span class="line"><span class="comment">argv[1]=this</span></span><br><span class="line"><span class="comment">argv[2]=is</span></span><br><span class="line"><span class="comment">argv[3]=my</span></span><br><span class="line"><span class="comment">argv[4]=code*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可选的实参从argv[1]开始，argv[0]保存程序的名字，而非用户输入。</p>
</li>
</ul>
<h2 id="含有可变形参和函数"><a href="#含有可变形参和函数" class="headerlink" title="含有可变形参和函数"></a>含有可变形参和函数</h2><ul>
<li><p>为了能编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为<strong>initializer_list</strong>的标准库类型；如果实参的类型不同，可以编写<strong>可变参数模板</strong>。 此外，还有一种特殊的形参类型（即<strong>省略符</strong>），可以用它传递可变数量的实参。</p>
</li>
<li><p>initializer_list提供的操作（定义在同名的头文件中）：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>initializer_list<T> lst</td>
<td>默认初始化</td>
</tr>
<tr>
<td>initializer_list<T> lst{a,b,c…}</td>
<td>lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中元素是const</td>
</tr>
<tr>
<td>lst2(lst) / lst2 = lst</td>
<td>拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后原始列表和副本共享元素</td>
</tr>
<tr>
<td>lst.size()</td>
<td>列表中的元素数量</td>
</tr>
<tr>
<td>lst.begin()</td>
<td>返回指向lst中首元素的指针</td>
</tr>
<tr>
<td>lst.end()</td>
<td>返回指向lst中尾元素下一位置的指针</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_msg</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>(); beg != il.<span class="built_in">end</span>(); ++beg)</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; *beg &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>和vector一样，initializer_list是一种模板类型，但是它的对象中的元素永远是常量值，无法改变其中元素的值。</p>
</li>
<li><p>省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为<strong>varargs</strong>的C标准库功能。</p>
</li>
<li><p>省略符形参仅仅用于C和C++通用的类型，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p>
</li>
<li><p>省略符形参只能出现在形参列表的最后一个位置，有两种形式：<code>void foo(parm_list, ...);</code>    /    <code>void foo(...);</code></p>
</li>
</ul>
<h1 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h1><ul>
<li>return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。</li>
<li>return语句有两种形式：<code>return;</code>      /      <code>return expression;</code></li>
</ul>
<h2 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h2><ul>
<li>没有返回值的函数只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。</li>
<li>void函数想要在它的中间位置提前退出，可以使用return语句。</li>
</ul>
<h2 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h2><ul>
<li><p>return语句返回值的类型必须与函数的返回类型相同，或者能隐式转换成函数的返回类型。</p>
</li>
<li><p><u>返回一个值的方式和初始化一个变量和形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。</u></p>
</li>
<li><p>若返回值非引用，则被拷贝到调用点。若返回值是引用，则它仅是它所引对象的别名。</p>
</li>
<li><h5 id="不要返回局部变量的引用和指针：函数终止意味着局部变量的引用将指向不再有效的内存区域。"><a href="#不要返回局部变量的引用和指针：函数终止意味着局部变量的引用将指向不再有效的内存区域。" class="headerlink" title="不要返回局部变量的引用和指针：函数终止意味着局部变量的引用将指向不再有效的内存区域。"></a><u><strong>不要返回局部变量的引用和指针</strong></u>：函数终止意味着局部变量的引用将指向不再有效的内存区域。</h5></li>
<li><p>*<u><strong>调用一个返回引用的函数返回左值，其他返回类型得到右值。</strong></u>*</p>
</li>
<li><p>列表初始化返回值：C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">process</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//excepted和actual是string对象</span></span><br><span class="line">  <span class="keyword">if</span>(expected.empty())</span><br><span class="line">    <span class="keyword">return</span>&#123;&#125;;                      <span class="comment">//返回一个空的vector对象</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (expected == actual)</span><br><span class="line">    <span class="keyword">return</span>&#123;<span class="string">"functionX"</span>,<span class="string">"Okay"</span>&#125;;    <span class="comment">//返回列表初始化的vector对象</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span>&#123;<span class="string">"functionX"</span>,expected,actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果列表为空，临时量执行<strong>值初始化</strong>；否则返回的值由函数的返回类型决定。</li>
<li>如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。</li>
<li>如果函数返回的是类类型，由类本身定义初始值如何使用。</li>
</ul>
</li>
<li><p>main函数如果没有return语句，则编译器会隐式地插入一条返回0的return语句。</p>
</li>
<li><p>一个函数调用了它自身，不管是直接地还是间接地，都称该函数为<strong>递归函数</strong>(recursive function)。</p>
</li>
</ul>
<h2 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h2><ul>
<li><p>函数不能返回数组因为数组不能被拷贝，但函数可以返回数组的指针或引用。</p>
</li>
<li><p>可以使用<strong>类型别名</strong>简化定义一个返回数组的指针或引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];    <span class="comment">//arrT是一个类型别名，它表示的类型是含有10个整数的数组</span></span><br><span class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span>[<span class="number">10</span>];    <span class="comment">//同上</span></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;       <span class="comment">//func返回一个指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明一个返回数组指针的函数：</p>
<ul>
<li><p>数组的声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];            <span class="comment">//arr是含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *p1[<span class="number">10</span>];            <span class="comment">//p1是一个含有10个指针的数组</span></span><br><span class="line"><span class="keyword">int</span> (*p2)[<span class="number">10</span>] = &amp;arr;   <span class="comment">//p2是一个指针，它指向含有10个整数的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和上面的声明一样，要定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而函数的形参列表也跟在函数名字后面且先于数组的维度：<code>Type (*function(parameter_list)) [dimension];</code>，例如：<code>int (*func(int i)) [10];</code>。最外面的括号不能省略。</p>
</li>
</ul>
</li>
<li><p>使用<strong>尾置返回类型</strong>(trailing return type)：<code>auto func(int i) -&gt; int(*)[10];   //func接受一个int类型实参，返回一个指针，该指针指向含有10个整数的数组</code>。</p>
</li>
<li><p>如果直到函数返回的指针指向的是哪个数组，就可以使用<strong>decltype</strong>关键字声明返回类型。<u>decltype的结果是数组，要向表示指向数组的指针必须在函数声明时加上一个*符号。</u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *arrPtr(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%<span class="number">2</span>)? &amp;odd : &amp;even;  <span class="comment">//返回一个指向数组的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><ul>
<li><p>如果同一个作用域内的几个函数名字相同但形参列表不同，即为<strong>重载(overloaded)函数</strong>。</p>
</li>
<li><p><strong><u>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开。</u></strong></p>
</li>
<li><p>如果形参是指针或引用，则通过区分其指的是常量对象还是非常量对象可以实现函数重载，此时const是底层的。</p>
</li>
<li><p>const_cast和重载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较两个string对象的长度，返回较短的那个引用</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">shorterString</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;=s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;r = shorterSting(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1),<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h2><ul>
<li><p>如果在内层作用域声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> <span class="built_in">read</span> = <span class="literal">false</span>;      <span class="comment">//新作用域：隐藏了外层的read</span></span><br><span class="line">  <span class="built_in">string</span> s = <span class="built_in">read</span>();      <span class="comment">//错误：read是一个bool值，而非函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;        <span class="comment">//新作用域：隐藏了外层的print</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Value: "</span>);       <span class="comment">//错误：print(const string &amp;)被隐层掉了</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="number">3.14</span>);            <span class="comment">//正确：调用print(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当调用print函数时，编译器首先寻找对该函数名的声明，找到的是接受int值的那个局部声明。一旦在当前作用域找到了所需的名字，编译器就会忽略掉外层作用域的同名实体。剩下的工作就是检查函数调用是否有效了。<u>在C++语言中，名字查找发生在类型检查之前。</u></p>
</li>
</ul>
<h1 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h1><h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><ul>
<li><p>某些函数有些形参，在函数的很多次调用中它们都被赋予一个相同的值，这个反复出现的值即为<strong>默认形参</strong>(defalut arguement).调用含有默认实参的函数时，可以包括该实参，也可以省略该实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span>::size_type sz;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>,sz wid = <span class="number">80</span>, <span class="keyword">char</span> <span class="built_in">background</span> = <span class="string">' '</span>)</span></span>;   <span class="comment">//每个形参都提供了默认实参</span></span><br><span class="line">sting window;</span><br><span class="line">window = screen();             <span class="comment">//等价于screen(24,80,' ')</span></span><br><span class="line">window = screen(<span class="number">66</span>);           <span class="comment">//等价于screen(66,80,' ')</span></span><br><span class="line">window = screen(<span class="number">66</span>,<span class="number">256</span>);       <span class="comment">//等价于screen(66,256,' ')</span></span><br><span class="line">window = screen(<span class="number">66</span>,<span class="number">256</span>,<span class="string">'#'</span>);</span><br><span class="line">window = screen(, , <span class="string">'?'</span>);      <span class="comment">//错误：只能省略尾部的实参</span></span><br><span class="line">window = screen(<span class="string">'?'</span>);          <span class="comment">//调用screen('?',80,' ')'?'隐式转换成string::size_type,也就是63</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数如果被声明过，它的后续声明<u>只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有必须都有默认值。</u>且不能修改一个已经存在的默认值。</p>
</li>
<li><p><u>局部变量不能作为默认实参。并且只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参。</u></p>
</li>
<li><p><u>用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：</u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">char</span> def = <span class="string">' '</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz = ht(), sz = wd, <span class="keyword">char</span> = def)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  def = <span class="string">'*'</span>;        <span class="comment">//改变默认实参的值</span></span><br><span class="line">  sz wd = <span class="number">100</span>;      <span class="comment">//隐藏了外层定义的wd，但没有改变默认值</span></span><br><span class="line">  window = screen();<span class="comment">//调用screen(ht(),80,'*')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h2><ul>
<li><p>在上文中编写了一个小函数，它的作用时比较两个string形参的长度并返回长度较小的string的引用。把这种规模较小的操作定义成函数由很多好处，但是有一个缺点：调用函数一般比求等价表达式要慢。</p>
</li>
<li><p>将函数定义成<strong>内联函数</strong>(inline),通常就是将它在每个调用点上“内联地展开。内联函数可以避免函数调用的开销。在函数的返回类型前加上关键字inline就可以声明称内联函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; shorterString(s1,s2)&lt;&lt;<span class="built_in">endl</span>;         <span class="comment">//将在编译过程中展开类似于下面的操作</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>() ? s1 : s2) &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</p>
</li>
<li><p><strong>constexpr函数</strong>(constexpr function)是指能用于==常量表达式==的函数。</p>
</li>
<li><p>定义constexpr必须符合两个规定：<strong><u>函数的返回类型和所有形参的类型都得是字面值类型；函数体中有且只有一条return语句。</u></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> new_sz &#123;<span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = new_sz();     <span class="comment">//正确。foo是一个常量表达式</span></span><br></pre></td></tr></table></figure>

<p>因为编译器能在程序编译时验证new_sz函数返回的是常量表达式，所以可用new_sz函数初始化constexpr类型变量foo。初始化开始时，编译器把对constexpr函数的调用替换成其他结果值。为了能在编译过程中随时展开，==constexpr函数被隐式地指定为内联函数。==</p>
</li>
<li><p>constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作，如空语句、类型别名以及using声明。</p>
</li>
<li><p>允许constexpr函数的返回值不是一个常量，当scale的实参是常量表达式时，它的返回值也是常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> size_t <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> </span>&#123;<span class="keyword">return</span> new_sz() * cnt; &#125;</span><br><span class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)];             <span class="comment">//正确：scale(2)是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;                     <span class="comment">//i不是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> a2[scale(i)];              <span class="comment">//错误：scale(i)不是常量表达式</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><ul>
<li><p>程序可包含一些用于调试的代码，只在开发时使用，发布时需屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。</p>
</li>
<li><p><strong>assert</strong>是一种<strong>预处理宏</strong>(preprocesser marco)。预处理宏就是一个==预处理变量==，它的行为类似于内联函数。</p>
</li>
<li><p>assert宏使用一个表达式作为它的条件：<code>assert (expr);</code>首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真，assert什么也不做。</p>
</li>
<li><p>assert宏定义在<strong>cassert</strong>头文件中。预处理器名字由预处理器而非编译器管理，因此可以使用预处理器名字而无需提供using声明。</p>
</li>
<li><p>assert宏常用于检查”不能发生“的条件。如一个输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值。此时程序可以包括一条这样的语句：<code>assert(word.size() &gt; thresold);</code></p>
</li>
<li><p>assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG则assert什么也不做，默认状态下没有定义。</p>
</li>
<li><p>可以使用一个#define语句定义NDEBUG，从而关闭调试状态。同时很多编译器提供了一个命令行选项使我们可以定义预处理变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ CC -D NDEBUG main.cc</span><br></pre></td></tr></table></figure>

<p>等价于在main.c文件的一开始写#define NDEBUG。</p>
</li>
<li><p>assert可以当成调试程序的一种辅助手段，但不可代替真正的运行时逻辑检查、错误检查等。</p>
</li>
<li><p>可用NDEBUG编写自己的条件测试代码，如果NEDBUG未定义，则执行<code>ifndef</code>和<code>endif</code>之间的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[], <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NEDBUG</span></span><br><span class="line">  <span class="built_in">cerr</span> &lt;&lt; __func__ &lt;&lt; <span class="string">": array size is "</span> &lt;&lt; <span class="built_in">size</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__func__</code>：编译器为每个函数定义了该变量，它是<code>const char</code>的静态数组，存放函数的名字</p>
</li>
<li><p>预处理器定义了另外几个对调试有用的名字：</p>
<ul>
<li><code>__FILE__</code>存放文件名的字符串字面值</li>
<li><code>__LINE__</code>存放当前行号的整型字面值</li>
<li><code>__TIME__</code>存放文件编译时间的字符串字面值</li>
<li><code>__DATE__</code>存放文件编译日期的字符串字面值</li>
</ul>
</li>
</ul>
<h1 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h1><ul>
<li><p>函数匹配第一步选定本次调用的对应的重载函数集，集合中的函数称为<strong>候选函数</strong>(candidate function):它们与被调用的函数同名，且其声明在调用点可见。</p>
</li>
<li><p>第二步从候选函数中选出能被这组实参调用的函数，这些函数称为<strong>可行函数</strong>(viable function):它们的形参数量与本次调用提供的实参相等，每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。</p>
</li>
<li><p>第三步是从可行函数中选择与本次调用最匹配的函数。在这过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。实参类型与形参类型越接近，它们匹配的越好。</p>
</li>
<li><p>含有多个形参的函数匹配，如果有且只有一个函数满足以下条件，则匹配成功：</p>
<ul>
<li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。</li>
<li>至少有一个实参的匹配优于其他可行函数提供的匹配。</li>
</ul>
<p>如果没有任何一个函数可行，则该调用是错误的，编译器将报告<strong>二义性调用</strong>的错误。</p>
</li>
<li><p>为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级：</p>
<ol>
<li>精确匹配：<ul>
<li>实参类型和形参类型相同。</li>
<li>实参从数组类型或函数类型转换成对应的指针类型。</li>
<li>向实参添加顶层const或者从实参从删除顶层const。</li>
</ul>
</li>
<li>通过const转换实现的匹配。</li>
<li>通过类型提升实现的匹配。</li>
<li>通过算术类型转换实现的匹配。</li>
<li>通过类类型转换实现的匹配。</li>
</ol>
</li>
</ul>
<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><ul>
<li><p>函数指针指向的是函数而非对象。函数指针指向特定的类型。</p>
</li>
<li><p>函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">legthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> (*pf) (<span class="keyword">const</span> <span class="built_in">string</span> &amp;,<span class="keyword">const</span> <span class="built_in">string</span> &amp;);   <span class="comment">//指向函数的指针，未初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当把函数名作为一个值使用时，该函数自动转换为指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare;</span><br><span class="line">pf = &amp;lengthCompare;<span class="comment">//两者等价</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以直接使用指向函数的指针调用该函数，无需解引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b1 = pf(<span class="string">"hello"</span>,<span class="string">"goodbye"</span>);</span><br><span class="line"><span class="keyword">bool</span> b2 = &amp;pf(<span class="string">"hello"</span>,<span class="string">"goodbye"</span>);</span><br><span class="line"><span class="keyword">bool</span> b3 = lengthCompare(<span class="string">"hello"</span>,<span class="string">"goodbye"</span>);<span class="comment">//三者等价</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><u>在指向不同函数类型的指针间不存在转换规则。</u></p>
</li>
<li><p>可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何任何一个函数。</p>
</li>
<li><p>如果定义了指向重载函数的指针，编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配。</p>
</li>
<li><p><strong>函数类型形参</strong>：和数组一样，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时形参看起来像函数，实际上被当作指针使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下两行等价</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2,<span class="keyword">bool</span> pf(<span class="keyword">const</span> <span class="built_in">string</span> &amp;,<span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span></span><br><span class="line"><span class="function"><span class="comment">//第三个形参是函数类型，被自动地转换成指向函数的指针</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2,<span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;,<span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">useBigger</span><span class="params">(s1,s2,lengthCompare)</span><span class="comment">//自动将函数legthCompare转换成指向该函数的指针</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用typedef和的decltype简化函数指针的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Func 和 Func2是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;           <span class="comment">//两者等价</span></span><br><span class="line"><span class="comment">//FuncP 和 Funcp2是指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span><span class="params">(*FuncP)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;,<span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;        <span class="comment">//两者等价，decltype地结果是函数类型，只有加上*才会得到指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可以返回指向函数类型的指针，但必须把返回类型写成指针形式。</strong>返回类型不会被自动当成对应的指针类型处理。</p>
</li>
<li><p>可以使用<strong>类型别名</strong>和<strong>尾置返回类型</strong>声明一个返回函数指针的函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*,<span class="keyword">int</span>);      <span class="comment">//P是函数类型</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span>(*)(<span class="keyword">int</span>*,<span class="keyword">int</span>);  <span class="comment">//PF是指针类型</span></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;            <span class="comment">//正确：PF是指向函数的指针，f1返回指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;             <span class="comment">//错误：F是函数类型，f1不能返回函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;            <span class="comment">//正确：显示地指定返回类型是指向函数的指针；</span></span><br><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span>*,<span class="keyword">int</span>);<span class="comment">//直接声明f1</span></span><br><span class="line">auto f1(int) -&gt; int (*)(int*,int);//尾置返回类型</span><br></pre></td></tr></table></figure>
</li>
<li><p>auto和decltype也可用于返回函数指针的原型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::<span class="function">size_type <span class="title">sumLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="built_in">string</span>::<span class="function">size_type <span class="title">largerLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(sumLength) *getFcn(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);    <span class="comment">//该函数返回一个指针，指向前两个函数中地一个</span></span><br></pre></td></tr></table></figure>



</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>DZY
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://carpediem-d.github.io/2020/10/22/%E3%80%8Ac++primer%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/" title="《c++primer》第六章 函数">https://carpediem-d.github.io/2020/10/22/《c++primer》第六章-函数/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/10/21/%E3%80%8Ac++primer%E3%80%8B%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%AF%AD%E5%8F%A5/" rel="prev" title="《c++primer》第五章 语句">
                  <i class="fa fa-chevron-left"></i> 《c++primer》第五章 语句
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/10/23/%E3%80%8Ac++primer%E3%80%8B%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/" rel="next" title="《c++primer》第七章 类">
                  《c++primer》第七章 类 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DZY</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">46k</span>
  </span>
</div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
















  <script>
    NProgress.configure({
      showSpinner: true
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });
  </script>


  








  

  


  
</body>
</html>
