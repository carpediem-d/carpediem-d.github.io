<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《c++primer》第二章 变量和基本类型</title>
      <link href="2020/10/13/20202013-%E3%80%8Ac++primer%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
      <url>2020/10/13/20202013-%E3%80%8Ac++primer%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="内置基本类型"><a href="#内置基本类型" class="headerlink" title="内置基本类型"></a>内置基本类型</h1><h2 id="算术类型-arithmetic-type"><a href="#算术类型-arithmetic-type" class="headerlink" title="算术类型(arithmetic type)"></a>算术类型(arithmetic type)</h2><ul><li><p>算术类型分为两类：整型(integral type,包括字符和布尔类型在内)和浮点型。</p></li><li><p>算术类型的尺寸在不同机器上有所差别，下表列出了C++标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸</p><a id="more"></a></li><li><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型</td><td>未定义</td></tr><tr><td>char</td><td>字符</td><td>8位</td></tr><tr><td>wchar_t</td><td>宽字符</td><td>16位</td></tr><tr><td>char16_t</td><td>Unicode字符</td><td>16位</td></tr><tr><td>char32_t</td><td>Unicode字符</td><td>32位</td></tr><tr><td>short</td><td>短整型</td><td>16位</td></tr><tr><td>int</td><td>整型</td><td>16位</td></tr><tr><td>long</td><td>长整型</td><td>32位</td></tr><tr><td>long long</td><td>长整型</td><td>64位</td></tr><tr><td>float</td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td>double</td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td>long double</td><td>扩展精度浮点数</td><td>10位有线数字</td></tr></tbody></table></li><li><ul><li>除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的(signed)和无符号的(unsigned)。类型int、short、long和long long都是带符号的，在前面加上unsigned就能得到无符号类型。类型unsigned int可以缩写为unsigned。</li><li>与其他整型不同，字符型被分成了三种：char、signed char、和unsigned char。char与signed char不同。char实际上会表现为带符号或不带符号的，具体哪种由编译器决定。</li></ul></li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>当在程序的某处我们使用了一种类型二对象应该取另一种类型的时，程序会自动进行类型转换。</p><p><code>bool b = 42;   //b为真</code>  </p><p><code>int i = b;   //i为1</code>  </p><p><code>i = 3.14;   //i为3</code></p><p><code>double pi = i;   //pi为3.0</code></p><p><code>unsigned char c = -1;   //假设char为8 bit，c的255</code></p><p><code>signed char c2 = 256;   //假设char为8 bit，c2的值是未定义的</code></p><p><code>unsigned u = 10; i = -42; std::cout&lt;&lt;u+i;   //如果i为32位，输出4294967264</code></p><ul><li>当我们赋给带符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</li><li>当我们赋给带符号类型一个超出它范围的值时，结果是<strong>未定义的</strong>(undefined)。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。</li></ul><h2 id="字面值常量-literal"><a href="#字面值常量-literal" class="headerlink" title="字面值常量(literal)"></a>字面值常量(literal)</h2><h3 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h3><ul><li>我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制，以0x或0X开头的代表十六进制。</li><li>默认情况下，十进制字面值是带符号数，八进制和十六进制字面值极可能是带符号也可能是无符号的。</li><li>类型short没有对应的字面值。</li><li>严格来说，十进制字面值不会是负数，负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。</li><li>浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e表示。默认为double。</li></ul><h3 id="字符和字符串常量"><a href="#字符和字符串常量" class="headerlink" title="字符和字符串常量"></a>字符和字符串常量</h3><ul><li>由单引号括起来的一个字符为char型字面值，双引号括起来的零个或多个字符则构成字符串字面值。</li><li>编译器在每个字符串的结尾处添加一个空字符(‘\0’)，因此字符串字面值的实际长度要比它的内容多1。</li></ul><h3 id="转义序列-escape-sequence"><a href="#转义序列-escape-sequence" class="headerlink" title="转义序列(escape sequence)"></a>转义序列(escape sequence)</h3><p>  有两类字符程序员不能直接使用：一类是<strong>不可打印</strong>(nonprintable)的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是在C++中有特殊含义的字符(单引号、双引号、问号、反斜线)。在这些情况下需要用到<strong>转义序列</strong>，转义序列均以反斜线开始，C++规定的转义序列包括：</p><p> <code>换行符   \n</code>    <code>横向制表符   \t</code>    <code>报警（响铃）符   \a</code>    <code>纵向制表符   \v</code>    <code>退格符   \b</code>    <code>双引号   \&quot;</code> </p><p><code>反斜线   \\</code>    <code>问号   \?</code>    <code>单引号   \&#39;</code>    <code>回车符   \r</code>    <code>进纸符   \f</code></p><ul><li>在程序中，上述转义字符被当作一个字符使用。</li><li>我们也可以使用泛化的转义序列，其形式是\x后紧跟1个或多个十六进制数字，或\后紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。</li><li>注意，如果反斜线\后面紧跟着的八进制数超过3个，只有前3个构成转义序列。相反，\x要用到后面紧跟着的所有数字。因为大多数机器的char型数据占8bit，所以超过八位的十六进制字符都是与前缀作为开头的扩展字符集一起使用。</li></ul><h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><p>通过添加下表中所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。</p><ul><li>字符和字符串字面值</li></ul><table><thead><tr><th>前缀</th><th>含义</th><th>类型</th></tr></thead><tbody><tr><td>u</td><td>Unicode16字符</td><td>char16_t</td></tr><tr><td>U</td><td>Unicode32字符</td><td>char32_t</td></tr><tr><td>L</td><td>宽字符</td><td>wchar_t</td></tr><tr><td>u8</td><td>UTF-8（仅用于字符串字面值常量）</td><td>char</td></tr></tbody></table><ul><li>整型和浮点型字面值</li></ul><table><thead><tr><th>后缀</th><th>最小匹配类型/类型</th></tr></thead><tbody><tr><td>u or U</td><td>unsigned</td></tr><tr><td>l or L</td><td>long</td></tr><tr><td>ll or LL</td><td>long long</td></tr><tr><td>f or F</td><td>float</td></tr><tr><td>l or L</td><td>long double</td></tr></tbody></table><p>对于一个整形字面值，我们可以将u与L或LL合在一起使用。</p><h3 id="布尔字面值和指针字面值"><a href="#布尔字面值和指针字面值" class="headerlink" title="布尔字面值和指针字面值"></a>布尔字面值和指针字面值</h3><ul><li>true和false是布尔类型的字面值。</li><li>nullptr是指针字面值。</li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1>]]></content>
      
      
      <categories>
          
          <category> 《c++primer》 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
